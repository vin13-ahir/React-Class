1. Are you using websocket to stream data
--> I do use websocket to stream data, when it requires real time updates. Suppose, if we are implementing a Chat application, which must require real time updates, I will use websocket to stream data. Otherwise, REST APIs works fine.

2. What specific strategy did you implement to make sure UI is not buggy 
--> I use controlled components, proper state management, prop validation, unit tests, and React DevTools to catch issues early.

3. Have you run into memory issues with data caching
--> Yes, when I need to work with large amount of data, which also takes a lot of time to load, and loading all at once also don't make any sense, I go with pagination, caching solution.

4. What is component memorization
--> It’s optimizing re-renders by caching a component’s rendered output until its props/state change.

5. How do React.memo, useMemo, useCallback work, what’s the main functionality 
	a.  Should we wrap every single function with useCallback 
	b.  Should we use useMemo for every variable
--> React.memo: Memorizes entire components,
useMemo: Memoizes computed values,
useCallback: Memoizes functions
a. No, only wrap expensive functions passed as props.
b. No, useMemo only for expensive calculations.

6. When does React render a component
--> On state change or prop change.

7. useEffect vs useLayoutEffect, which one will be triggered first 
--> useLayoutEffect runs synchronously after DOM updates but before paint; useEffect runs asynchronously after paint.

8.  Have you worked on any custom hooks, when do you need it, why not regular functions 
--> When logic is reused across components. Hooks provide cleaner separation than plain functions since they work with React’s lifecycle.

9.  Tell me about something you built that you are proud of 
--> A reusable UI component library that improved consistency.

10. What are you looking at when writing unit tests, thinking process 
--> I test logic, UI behavior on different browsers, and API testing.

11. Have you used any mock up library for unit testing 
--> Yes, I’ve used Jest with libraries like React Testing Library and MSW (Mock Service Worker).

12. Are you familiar with CSS 3, LESS, or SASS 
--> Yes, familiar with all. Prefer CSS Modules or SASS for scalable styling.

13. What’s your full stack experience 
--> React + Node.js + Express, sometimes integrated with databases like MongoDB or MySQL depends on the requirement.

14. How does useEffect syntax look like 
	a.  What does the cleanup syntax look like 
--> useEffec(() => {
//code to perform

return () => {
//cleanup code
}
}, [dependancy_array]);

15. How to make sure your react application is working properly on different browsers? 
	a.  What if it is not compatible with one browser?
--> Use testing tools like BrowserStack, feature detection, and polyfills.
a. If incompatible, apply fallbacks or conditional rendering.

16. Do you prefer context api or redux? How do you compare them 
--> It depends on the project requirements, if the project is not too complex, I prefer contex API as its Good for simple Logic state management, while for complex project I prefer Redux, as it has better complex state management, middleware, and debugging also.

17. Have you used rtk 
--> Yes, it simplifies Redux with less boilerplate and built-in best practices.

18. What is immutability 
--> Data is never mutated directly; instead, new copies are created. This makes React state predictable and efficient.

19. Do you use javascript or typescript for react 
--> I use javascript for react by adding JSDoc and linting for safety, but I have worked with TypeScript also.

20. Do you have any questions
--> No, I don't have any questions.