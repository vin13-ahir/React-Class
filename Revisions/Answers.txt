1.JSX stands for JavaScript XML. It's look likes and HTML but a syntax for JavaScript Syntax Extension.
2. States are Internal properties, while props are External properties. States are mutable using setState(), while props are immutable means read-only properties. States are controlled by the Component itself, while props are controlled by parent components and passes to a child component. 
3. Controlled components are the components handled/controlled by React itself, while an Uncontrolled components are the one handled by DOM itself.
4. useState hook, allows user to manage state inside a component. Its syntax is like, const [state, setState] = useState(). state gets the intial value using useState(), while we can change state value using setState() method.
5. useEffect() hook, allows user to manage a side effects. Syntaxt is like, useEffect(callback_function, depedancy_array). Here, a callback_function / function is the function we want to run or execute, while the particular depency matched.
6. Both useMemo() and useCallback() hooks are used to cache a value or a function of an expensive component. useMemo() caches a value, while useCallback() caches a function. Syntax is like, useMemo(function, dependancy_array) / useCallback(function, dependancy_array). 
7. Class components are extends React.components while we can directly create a function and export the same in functional components. In Class compnents to use lifecycle methods, we need to use componentDidMount(), componentDidUpdate(), and componentWillUnmount(), while in Functional one, we have hooks which make things easier. In Class components, this keyword is used to refer the values, which is not so in Functional one. 
8. A normal React component will re-render whenever its parent re-renders, even if the data is the same. A Pure Component automatically compares the old props/state with the new props/state (using a shallow comparison).
If nothing has changed, it just skips the re-render, making your app faster.
9. When a props is unneccesarily passed to multiple components, to send it to the destination, is called prop drilling. Suppose we have three components A, B, and C, in which C is accessible by B, B is aceessible by A, so to send data or props to C, we first send the data or props to B and the C, but we only need that data in C, still we're passing it to B, this is called prop drilling. We can avoid prop drilling using contextAPI. Wecan create a context and then assign a value and then wrap the main App components aroun contextProvider, and then usethe context directly anywhere in the App.
10. useRef() hook allows to upadte or mange state value without re-rendering. Syntax is like, const refname = useRef(). To access the value, we need to use refname.current. Then we can muate the value by doing, refname.current + 1.